## 게임의 기본 구조

---

본문은 &lt;C를 이용한 게임 프로그래밍&gt;\(아래 링크\)를 공부하고 다시 정리하였음.

[http://nowcampus.tistory.com/entry/3%EC%9E%A5?category=655340](http://nowcampus.tistory.com/entry/3장?category=655340)

1. \[초기화\] -&gt; \[데이터 갱신\] -&gt; \[화면 출력\] -&gt; \[해제\]

```
//01.초기화 : 게임에 필요한 기본 데이터 읽고 각종 변수 초기화 (로딩중..)
init() 

//02~03. 데이터갱신과 화면출력은 무한반복 실행
while(1)  
{
    //데이터갱신 : 입력장치에 의한 갱신 or 스스로 데이터 갱신(인공지능, 충돌, 패턴, 물리 등)
    Update()

    //화면출력 : 데이터 갱신을 통해 확정된 데이터를 문자 또는 이미지로 출력한 것
    //게임은 결국 화면에 출력된 캐릭터를 이용해 진행하는 것이므로 출력이 중요
    Render()

}

//04.해제 : 동적으로 할당된 메모리 해제 or 초기화에서 생성한 객체 해제
//여기서 객체는 사운드 엔진, 물리 엔진, 그래픽 엔진(DirectX, OpenGL)등을 말함
Release()
```

* 초기화 - 한 번만 실행됨
* 해제 - 게임 끝나면 해당 게임에 사용 되었던 메모리 OS에 반환
* C언어 함수 단위로 이루어져 있으니, 이런 로직 옮길 때 함수로 잘라서 선언할 수 있음

  * 그 선언한 함수 안에 초기화라든가 데이터 갱신이라든가 이런 내용들이 들어가면 되는 것
  * 반복문\(while\) 안에 무한반복 탈출할 조건 들어가야 하는데, Update\(\)에 들어가는 경우가 많음

* 무한 반복 형식

```
while(1)
{

}

for( ; ; )
{

}
```

1. 대기

2. cpu의 속도에 따라 while 깜박이는 속도 달라짐

3. 1초에 30번의 깜박임\(화면 전환, 프레임\)이 이루어지면 사람 눈 속일 수 있음\(연결된 것처럼\)

4. 근데 너무 빨리 깜박깜박깜박거리면 보기 불편하니까, 33ms마다 한 프레임 보여줄 수 있도록 대기\(딜레이\) 설정

5. `OldTime`은 데이터 갱신-화면출력 전에 시간, `CurTime`은 화면출력 끝난 이후 시간

6. `CurTime-OldTime > 33`인 경우에는 다음 장면 렌더링으로 넘어가기 위해 `break`

7. `OldTime` 갱신 전, 초기화 안 해주면 CurTime-OldTime이 음수가 나올 수도 있음\(에러\)

1~3까지 본 구조 모든 게임에 다 사용되는 기본적인 구조이고, 좀 더 연장해보면 DirectX까지도 이런 구조로 이루어져 있다는 것 기억

4.게임 요소의 동기화

* 동기화 - 뭔가를 맞춘다는 것,  프레임값을 기준으로 or 시간을 기준으로 맞추는 법 있음
* 프레임값을 이용하는 방법
  * 프레임은 게임이 진행되면 계속 증가하는 값
    * 프레임 값을 저장하기 위한 전역 변수 하나 필요하겠다 
      * 만든 변수 언제 쓰나? 렌더 끝나고\(대기 빠져 나오고\) 프레임++
    * 1초에 30fps라면, 90fps는 3초인 것을 알 수 있음. 
      * 몇 프레임인지 알면 얼마나 시간이 흘렀는지도 알 수 있음
  * 예전에는 이렇게 프레임 값을 기준으로 출력을 했었음, 성능이 낮았을 때, 지금은 아니지만.
    * 20 frame에는 적 캐릭터 2개, 50 frame에는 적 캐릭터 1개 등등.... 
* 시간 간격을 이용한 방법
  * 시간대는 다를 수 있지만 '1분' 이라는 값\(크기\)는 같기 때문에 시간을 동기화에 사용 가능
  * 성능이 아주 낮은 컴퓨터들은 데이터 갱신-렌더 시간이 오래 걸려 프레임이 뚝뚝 끊기겠지만, 시간 간격\(경과 시간\)을 이용하면 그런 부분들이 해결이 됨
    * 갱신-렌더 시간이 오래 걸려도 출현 시간 + 1초 후, 같이 설정하기 때문에 뚝뚝 끊기는 부분이 해결 되는건가? 준비하는 시간은 어떻게 처리 되지? 혹은 준비 시간 무시해도 되는 크기인가? or 딜레이 최소화 할 수 있게 로직을 짜서 이런 문제를 예방하겠지? 다 불러오는 방법이 있을 수 있겠는데 그럼 메모리 엄청 잡아먹을 테니까 아 이래서 게임에서 메모리 관련된 애들-포인터 등-이 중요하다 중요하다 하는건가
  * * 2초에는 적 캐릭터 2개, 4초 지나면 적 캐릭터 1개 등등...
  * 오늘날에 많이 쓰이는 방법이고, 경과 시간을 이용해 캐릭터가 이동한 거리까지 체크를 할 수 있음

#### 키워드

* 초기화-데이터 갱신-렌더-해제
  * 함수 단위로 쪼개서 내용 넣는다
* 대기 : `OldTime`, `CurTime`
* 게임 요소 동기화 : `g_nFrameCount++;`
  * 프레임 : 게임이 진행되면 계속 증가하는 값
    * 몇 프레임인지 알면 시간이 얼마나 흘렀는지 알 수 있음
    * **렌더-프레임-cpu-while 깜박깜박-대기-동기화-경과 시간**
  * 경과 시간\(시간 간격\)을 이용해 캐릭터가 이동한 거리까지 체크 가능

#### 미해결 문제

* [ ] visual studio 단축키
  atom 패키지 쓸 때 문장 중간에서 다음 줄로 넘어갈 수 있는 단축키? 편했는데 찾아도 안 나오네 ㅜㅜ 없으니 은근 매우 불편..
* [ ] 렌더링-cpu-메모리
  * [ ] 현재 어떻게 구현되고 있는지
  * [ ] 연결된 화면처럼 보이게 하는 기법\(로직\)
  * [ ] 뚝뚝 끊기지 않으면서도 메모리 최적화를 위한 기법\(로직\)

#### 멘탈

* 연말, 연초인데 괜찮겠지, 하고 조금 놀았더니 머리가 또 안 돌아가는 느낌 엉엉
* 기껏 몰입 되게 만들어 놓은거 잠깐 방심해서 망칠 뻔 했다.
* 초조해서 몰아 붙이면 안 되지만, 좋은 습관을 유지할 수 있도록은 노력하자. 



